# **Active Recordと参照整合性**

## **7.1 Active Recordの設計思想**
Active Recordパターンでは、**高度な処理はデータベースではなくモデル側に配置すべき** という考え方があります。そのため、トリガーや制約などのデータベース機能が必ずしも推奨されるわけではありません。

例えば、`validates :foreign_key, uniqueness: true` のようなバリデーションを利用すると、**データの整合性をモデルレベルで保証** できます。また、関連付けの `dependent` オプションを利用すると、**親オブジェクト削除時に子オブジェクトも削除される** という動作をアプリケーションレベルで実現できます。

---

## **7.2 参照整合性の確保**
Active Recordは、**外部キー制約やユニークインデックスをデータベースレベルで適用することを直接サポートしていません**。しかし、`execute` メソッドを使用することで任意のSQLを実行し、**データベースの整合性を補完** できます。

```ruby
class AddForeignKeyToOrders < ActiveRecord::Migration[8.0]
  def change
    execute "ALTER TABLE orders ADD CONSTRAINT fk_orders_users FOREIGN KEY (user_id) REFERENCES users(id);"
  end
end
```

このように、**外部キー制約をデータベース側で設定** することで、アプリケーションレベルだけでなく、データベースレベルでも参照整合性を担保できます。

---

## **7.3 データベース制約の必要性**
モデルでバリデーションを適用するだけでは、**データの一貫性を完全に保証することはできません**。例えば、**複数のプロセスが並行してデータを操作する場合**、モデルのバリデーションだけでは不十分であり、データベースレベルの制約が必要です。

### **データベース制約の推奨事項**
| 制約の種類 | 推奨適用先 |
|------------|-----------------|
| **外部キー制約** | 親テーブルと子テーブルのリレーション |
| **ユニーク制約** | 一意のデータを保持するカラム（例: `email`） |
| **NOT NULL 制約** | 必須カラム（例: `name`、`created_at`） |
| **CHECK 制約** | 数値や文字列の制限（例: `age >= 18`） |

---

## **7.4 Active Recordとデータベース制約の併用**
Active Recordのバリデーションとデータベースの制約は、それぞれ異なる役割を果たします。

✅ **Active Recordのバリデーション**
- ユーザーインターフェースレベルでのデータチェック
- エラーメッセージのカスタマイズが可能
- 一時オブジェクトのバリデーションに適用

✅ **データベースの制約**
- データの一貫性を強制
- アプリケーション外からのデータ挿入にも対応
- 競合状態を防ぐ（複数プロセスによる同時処理）

例えば、モデルのバリデーションとデータベースの制約を併用することで、**整合性の高いデータ管理が可能** になります。

```ruby
class User < ApplicationRecord
  validates :email, presence: true, uniqueness: true
end
```
```ruby
class AddUniqueIndexToUsers < ActiveRecord::Migration[8.0]
  def change
    add_index :users, :email, unique: true
  end
end
```

このようにすることで、**アプリケーションレベルとデータベースレベルの両方でデータの一貫性を保証** できます。

---

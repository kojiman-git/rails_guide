# 1. バリデーションの概要

## 概要
バリデーションとは、データが有効であることを確認し、不正なデータがデータベースに保存されないようにする仕組みです。以下のようなシンプルなバリデーションを実装できます。

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

このバリデーションにより、`name`属性が存在しない場合は無効となり、データベースへの保存が阻止されます。

## 1.1 バリデーションを行う理由
バリデーションの主な目的は、アプリケーションのデータの整合性を保つことです。たとえば、ユーザーのメールアドレスや住所が正しく入力されていることを保証するために、バリデーションを行います。

モデルレベルでのバリデーションは、データベースの種類やバージョンに依存せず、エンドユーザーが回避できないため、信頼性が高くなります。Railsでは、標準でさまざまなバリデーションヘルパーが提供されており、カスタムバリデーションの作成も可能です。

## 1.2 Railsバリデーション以外の検証方法
Railsのバリデーション以外にも、データの検証を行う方法があります。

### 1.2.1 データベースレベルの制約
データベースの制約やストアドプロシージャを利用してバリデーションを実装できます。特に、データベースが他のアプリケーションでも使用される場合は、データベースレベルのバリデーションが有効です。しかし、データベースに依存するため、テストや保守が複雑になる可能性があります。

### 1.2.2 クライアント（ブラウザ）側のバリデーション
JavaScriptを使用して、入力ミスを即座に通知できます。ただし、ユーザーがJavaScriptをオフにするとバイパスされる可能性があるため、他のバリデーションと組み合わせて使用することが推奨されます。

### 1.2.3 コントローラレベルのバリデーション
コントローラでバリデーションを実装することも可能ですが、コードが複雑になりやすく、テストや保守が困難になるため、推奨されません。

## 結論
Railsでは、基本的にモデルレベルでバリデーションを実装するのが最適です。ただし、状況によっては他のバリデーション方法を併用することで、より堅牢なデータ管理が可能になります。

# 1.3 バリデーションが実行されるタイミング

## 概要
Active Recordのオブジェクトには、データベースの行に対応するものと、そうでないものの2種類があります。オブジェクトを`new`メソッドで作成しただけではデータベースに保存されませんが、`save`メソッドを呼ぶことで保存されます。

## オブジェクトの状態確認
`persisted?`メソッドや`new_record?`メソッドを使うと、オブジェクトが既にデータベース上に存在するかどうかを確認できます。

```ruby
p = Person.new(name: "Jane Doe")
p.new_record?  #=> true
p.persisted?   #=> false
p.save         #=> true
p.new_record?  #=> false
p.persisted?   #=> true
```

新規レコードを保存すると、SQLの`INSERT`操作が実行され、既存レコードを更新すると`UPDATE`操作が実行されます。バリデーションは、これらのSQLコマンドがデータベースに送信される前に実行されます。

## バリデーションが失敗した場合
バリデーションが失敗すると、オブジェクトは無効（invalid）とされ、`INSERT`や`UPDATE`は実行されません。この仕組みにより、無効なデータがデータベースに保存されるのを防ぎます。

## バリデーションをトリガーするメソッド
以下のメソッドはバリデーションを実行し、有効なデータのみを保存します。

- `create`
- `create!`
- `save`
- `save!`
- `update`
- `update!`

`!`が付いたメソッド（例: `save!`）は、バリデーションに失敗すると例外を発生させます。一方、`!`なしのメソッド（`save`や`update`）は無効な場合に`false`を返します。

## 注意点
Railsには、バリデーションをトリガーしないメソッドも存在します。それらを使用すると、無効なデータがデータベースに保存される可能性があるため注意が必要です。

## 結論
バリデーションは、Active Recordオブジェクトのデータ整合性を保つ重要な仕組みです。適切に活用することで、エラーの少ない堅牢なアプリケーションを構築できます。

# 1.4 バリデーションのスキップ

## 概要
Active Recordには、バリデーションをスキップしてオブジェクトを保存できるメソッドがいくつか存在します。これらのメソッドを使用すると、無効なデータがデータベースに保存される可能性があるため、慎重に利用する必要があります。

## バリデーションをスキップするメソッド
以下のメソッドは、バリデーションを行わずにデータを保存または更新します。

- `decrement!`
- `decrement_counter`
- `increment!`
- `increment_counter`
- `insert`
- `insert!`
- `insert_all`
- `insert_all!`
- `toggle!`
- `touch`
- `touch_all`
- `update_all`
- `update_attribute`
- `update_attribute!`
- `update_column`
- `update_columns`
- `update_counters`
- `upsert`
- `upsert_all`
- `save(validate: false)`

特に、`save(validate: false)` を使用すると、明示的にバリデーションをスキップしてオブジェクトを保存できます。この方法を使用すると、無効なデータがそのままデータベースに保存される可能性があるため、細心の注意を払って利用する必要があります。

## 注意点
バリデーションをスキップすると、データの一貫性が失われる可能性があるため、通常の開発では避けるべきです。これらのメソッドを使用する場合は、データの整合性を保証するための別の仕組みを導入することを推奨します。

## 結論
バリデーションをスキップするメソッドは、特定の状況で便利に使えますが、データの整合性を損なう可能性があるため慎重に扱うべきです。使用する際は、RailsのAPIドキュメントをよく確認し、適切な場面でのみ利用するようにしましょう。

# 1.5 有効性をチェックする

## 概要
Railsは、Active Recordオブジェクトを保存する直前にバリデーションを実行します。バリデーションに失敗すると、オブジェクトは保存されません。

## バリデーションの手動実行
`valid?`メソッドを使用すると、バリデーションを手動でトリガーできます。このメソッドはオブジェクトのバリデーションを実行し、エラーがなければ`true`、エラーがある場合は`false`を返します。

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end

Person.new(name: "John Doe").valid? #=> true
Person.new(name: nil).valid?         #=> false
```

## バリデーションエラーの取得
`errors`インスタンスメソッドを使用すると、失敗したバリデーションの詳細にアクセスできます。

```ruby
person = Person.new
person.errors.size #=> 0 (保存前のためエラーなし)

person.valid? #=> false
person.errors.full_messages.first #=> "Name can't be blank"
```

新規作成したオブジェクトでは、`valid?`を実行するまではエラーが出力されません。バリデーションが自動的に実行されるのは、`create`や`save`メソッドを使用してオブジェクトを保存するときのみです。

## `invalid?` メソッド
`invalid?`メソッドは`valid?`と逆の動作を行います。バリデーションを実行し、エラーがあれば`true`、エラーがなければ`false`を返します。

```ruby
person.invalid? #=> true
```

## 結論
バリデーションの有効性を手動で確認することで、データの整合性を保証しながら適切な処理を行うことができます。特に`valid?`や`invalid?`を活用すると、オブジェクトが適切にバリデーションを通過するかを簡単にチェックできます。

# Active Record バリデーションエラーの処理

## 概要
Active Recordの`errors`オブジェクトを使用すると、バリデーションエラーを確認し、適切に処理できます。エラーメッセージを取得したり、手動でエラーを追加したりすることが可能です。

## このガイドの内容
1. **`errors[:attribute]` を使用したバリデーションエラーの確認方法**
2. **エラーメッセージの取得と判定**
3. **`errors.add` を用いた手動エラー追加**

## 1.6 エラーを調べて処理する
### `errors[:attribute]` を使用したバリデーションエラーの確認
`errors[:attribute]` を使うことで、特定の属性に対するバリデーションエラーを取得できます。エラーがある場合はメッセージの配列が、エラーがない場合は空の配列が返されます。

### **使用例**
```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end

new_person = Person.new
new_person.errors[:name] #=> [] (エラーなし)
new_person.errors[:name].any? #=> false

create_person = Person.create
create_person.errors[:name] #=> ["can't be blank"] (nameが必須のためエラー)
create_person.errors[:name].any? #=> true
```

### `errors.add` を用いた手動エラー追加
`errors.add` メソッドを使用すると、カスタムエラーメッセージを手動で追加できます。これは、特定のバリデーション条件を実装する際に便利です。

### **使用例**
```ruby
class Person < ApplicationRecord
  validate do |person|
    errors.add :name, :too_short, message: "長さが足りません"
  end
end
```

この方法を使えば、モデル内で柔軟にバリデーションエラーを追加し、カスタマイズできます。

より詳細なエラーハンドリングについては、バリデーションエラーの取り扱いに関するセクションを参照してください。



